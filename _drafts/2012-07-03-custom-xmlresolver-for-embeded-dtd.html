---
layout: post
title: Custom XmlResolver for embeded DTD
date: '2012-07-03T08:28:00.000+02:00'
author: Marek Mierzwa
tags:
- xml
- DTD
- XmlResolver
- XmlSerializer
modified_time: '2012-07-03T08:38:23.814+02:00'
blogger_id: tag:blogger.com,1999:blog-2283486810269355053.post-1307989842451191515
blogger_orig_url: http://byteloom.blogspot.com/2012/07/custom-xmlresolver-for-embeded-dtd.html
---

Writing a component for parsing XML files with XMLSerializer I had to provide DTD validation (DTD file was already created long time ago so there was no sense for creating XSD schema). The component must have been able to work in console application and web app (as a SharePoint timer job) so there was no chance to guarantee the same paths for DTD file (which was always specified in doctype directive in processed files). In such situation I've decided to deliver the DTD file as embedded resource in component assembly.<br /><a name='more'></a><br />If you had ever faced the similar problem you probably know that standard XmlResolver implementations in .Net framework will not able to find DTD in such location. If you try you will probably get an exception like this:<br /><br /><pre class="brush: text">System.InvalidOperationException: There is an error in XML document (0, 0). ---> System.Xml.XmlException: Cannot resolve external DTD subset - public ID = '', system ID = 'yourDTDFileDefinedInDoctype.dtd'.<br /></pre><br />or something similar. Thats why you have to provide the XmlSerializer some your own mechanism that will find the DTD file - custom <a href="http://msdn.microsoft.com/en-us/library/system.xml.xmlresolver.aspx" target="_blank">XmlResolver</a>.<br />There is a good example how to do this on <a href="http://msdn.microsoft.com/en-us/library/bb669135.aspx" target="_blank">MSDN</a>. I've changed it a little bit to cover the use case with embedded resources.<br /><br /><pre class="brush: csharp">public class XmlEmbededResolver : XmlUrlResolver<br />{<br />    private readonly string dtdResourcePathPrefix;<br />    <br />    public XmlEmbededResolver(string dtdResourcePathPrefix)<br />    {<br />        this.dtdResourcePathPrefix = dtdResourcePathPrefix;<br />    }<br />    <br />    public override object GetEntity(Uri absoluteUri, string role, Type ofObjectToReturn)<br />    {<br />        if (absoluteUri == null)<br />        {<br />            throw new ArgumentNullException("absoluteUri");<br />        }<br />        <br />        if (isDocumentTypeDefinitionFile(absoluteUri) &&<br />            (ofObjectToReturn == null || ofObjectToReturn == typeof(Stream)))<br />        {<br />            var filePath = dtdResourcePathPrefix + getFileName(absoluteUri);<br />            var resourceStream = Assembly.<br />                GetExecutingAssembly().<br />                GetManifestResourceStream(filePath);<br />                <br />            if (resourceStream == null)<br />            {<br />                throw new FileNotFoundException("Embeded DTD file not found", filePath);<br />            }<br /><br />            return resourceStream;<br />        }<br /><br />        return base.GetEntity(absoluteUri, role, ofObjectToReturn);<br />    }<br /></pre><br />Parameter dtdResourcePathPrefix in constructor points the location of DTD (without file name) in the assembly (usually the default namespace + folder path).<br />The utility method isDocumentTypeDefinitionFile() is used for determining if entity passed by XmlSerializer to resolve is actually an DTD file (XmlResolver is used resolve any kind of external resources defined in XML file):<br /><br /><pre class="brush: csharp">private static bool isDocumentTypeDefinitionFile(Uri absoluteUri)<br />{<br />    return absoluteUri.IsFile &&<br />    absoluteUri.AbsolutePath.EndsWith(".dtd");<br />}<br /></pre><br />getFileName(), as its name suggests, returns the name of DTD:<br /><pre class="brush: csharp">private static string getFileName(Uri absoluteUri)<br />{<br />    return absoluteUri.Segments.Last();<br />}<br /></pre><br />Using the custom resolver is pretty simple - you just pass it as setting to XmlReader in Create() method:<br /><br /><pre class="brush: csharp">var readerSettings = new XmlReaderSettings<br />{<br />    ProhibitDtd = false,<br />    ValidationType = ValidationType.DTD,<br />    XmlResolver = new XmlEmbededResolver(dtdResourcePathPrefix)<br />};<br /><br />using (var reader = XmlReader.Create(xmlFileStream, readerSettings))<br />{<br />    var serializer = new XmlSerializer(typeof (YourXmlDataType));<br />    var rawImportEntry = (YourXmlDataType)serializer.Deserialize(reader);<br />    ...<br />}<br /></pre><br />I can easily imagine other implementations of XmlResolver - for example to provide external resources from the web services (of course if someone see any sense in creating such thing ;-)